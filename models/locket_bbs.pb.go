// Code generated by protoc-gen-go-bbs. DO NOT EDIT.
// versions:
// - protoc-gen-go-bbs v0.0.1
// - protoc            v5.29.4
// source: locket.proto

package models

import (
	strconv "strconv"
)

type TypeCode int32

const (
	UNKNOWN  TypeCode = 0
	LOCK     TypeCode = 1
	PRESENCE TypeCode = 2
)

// Enum value maps for TypeCode
var (
	TypeCode_name = map[int32]string{
		0: "UNKNOWN",
		1: "LOCK",
		2: "PRESENCE",
	}
	TypeCode_value = map[string]int32{
		"UNKNOWN":  0,
		"LOCK":     1,
		"PRESENCE": 2,
	}
)

func (m TypeCode) String() string {
	s, ok := TypeCode_name[int32(m)]
	if ok {
		return s
	}
	return strconv.Itoa(int(m))
}

// Prevent copylock errors when using ProtoResource directly
type Resource struct {
	Key   string `json:"key,omitempty"`
	Owner string `json:"owner,omitempty"`
	Value string `json:"value,omitempty"`
	// Deprecated: marked deprecated in locket.proto
	Type     string   `json:"type,omitempty"`
	TypeCode TypeCode `json:"typeCode,omitempty"`
}

func (this *Resource) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Resource)
	if !ok {
		that2, ok := that.(Resource)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.Key != that1.Key {
		return false
	}
	if this.Owner != that1.Owner {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.TypeCode != that1.TypeCode {
		return false
	}
	return true
}
func (m *Resource) GetKey() string {
	if m != nil {
		return m.Key
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *Resource) SetKey(value string) {
	if m != nil {
		m.Key = value
	}
}
func (m *Resource) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *Resource) SetOwner(value string) {
	if m != nil {
		m.Owner = value
	}
}
func (m *Resource) GetValue() string {
	if m != nil {
		return m.Value
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *Resource) SetValue(value string) {
	if m != nil {
		m.Value = value
	}
}

// Deprecated: marked deprecated in locket.proto
func (m *Resource) GetType() string {
	if m != nil {
		return m.Type
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}

// Deprecated: marked deprecated in locket.proto
func (m *Resource) SetType(value string) {
	if m != nil {
		m.Type = value
	}
}
func (m *Resource) GetTypeCode() TypeCode {
	if m != nil {
		return m.TypeCode
	}
	var defaultValue TypeCode
	defaultValue = 0
	return defaultValue
}
func (m *Resource) SetTypeCode(value TypeCode) {
	if m != nil {
		m.TypeCode = value
	}
}
func (x *Resource) ToProto() *ProtoResource {
	if x == nil {
		return nil
	}

	proto := &ProtoResource{
		Key:      x.Key,
		Owner:    x.Owner,
		Value:    x.Value,
		Type:     x.Type,
		TypeCode: ProtoTypeCode(x.TypeCode),
	}
	return proto
}

func (x *ProtoResource) FromProto() *Resource {
	if x == nil {
		return nil
	}

	copysafe := &Resource{
		Key:      x.Key,
		Owner:    x.Owner,
		Value:    x.Value,
		Type:     x.Type,
		TypeCode: TypeCode(x.TypeCode),
	}
	return copysafe
}

func ResourceToProtoSlice(values []*Resource) []*ProtoResource {
	if values == nil {
		return nil
	}
	result := make([]*ProtoResource, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func ResourceFromProtoSlice(values []*ProtoResource) []*Resource {
	if values == nil {
		return nil
	}
	result := make([]*Resource, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}

// Prevent copylock errors when using ProtoLockRequest directly
type LockRequest struct {
	Resource     *Resource `json:"resource,omitempty"`
	TtlInSeconds int64     `json:"ttlInSeconds,omitempty"`
}

func (this *LockRequest) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LockRequest)
	if !ok {
		that2, ok := that.(LockRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.Resource == nil {
		if that1.Resource != nil {
			return false
		}
	} else if !this.Resource.Equal(*that1.Resource) {
		return false
	}
	if this.TtlInSeconds != that1.TtlInSeconds {
		return false
	}
	return true
}
func (m *LockRequest) GetResource() *Resource {
	if m != nil {
		return m.Resource
	}
	return nil
}
func (m *LockRequest) SetResource(value *Resource) {
	if m != nil {
		m.Resource = value
	}
}
func (m *LockRequest) GetTtlInSeconds() int64 {
	if m != nil {
		return m.TtlInSeconds
	}
	var defaultValue int64
	defaultValue = 0
	return defaultValue
}
func (m *LockRequest) SetTtlInSeconds(value int64) {
	if m != nil {
		m.TtlInSeconds = value
	}
}
func (x *LockRequest) ToProto() *ProtoLockRequest {
	if x == nil {
		return nil
	}

	proto := &ProtoLockRequest{
		Resource:     x.Resource.ToProto(),
		TtlInSeconds: x.TtlInSeconds,
	}
	return proto
}

func (x *ProtoLockRequest) FromProto() *LockRequest {
	if x == nil {
		return nil
	}

	copysafe := &LockRequest{
		Resource:     x.Resource.FromProto(),
		TtlInSeconds: x.TtlInSeconds,
	}
	return copysafe
}

func LockRequestToProtoSlice(values []*LockRequest) []*ProtoLockRequest {
	if values == nil {
		return nil
	}
	result := make([]*ProtoLockRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func LockRequestFromProtoSlice(values []*ProtoLockRequest) []*LockRequest {
	if values == nil {
		return nil
	}
	result := make([]*LockRequest, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}

// Prevent copylock errors when using ProtoLockResponse directly
type LockResponse struct {
}

func (this *LockResponse) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LockResponse)
	if !ok {
		that2, ok := that.(LockResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	return true
}
func (x *LockResponse) ToProto() *ProtoLockResponse {
	if x == nil {
		return nil
	}

	proto := &ProtoLockResponse{}
	return proto
}

func (x *ProtoLockResponse) FromProto() *LockResponse {
	if x == nil {
		return nil
	}

	copysafe := &LockResponse{}
	return copysafe
}

func LockResponseToProtoSlice(values []*LockResponse) []*ProtoLockResponse {
	if values == nil {
		return nil
	}
	result := make([]*ProtoLockResponse, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func LockResponseFromProtoSlice(values []*ProtoLockResponse) []*LockResponse {
	if values == nil {
		return nil
	}
	result := make([]*LockResponse, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}

// Prevent copylock errors when using ProtoReleaseRequest directly
type ReleaseRequest struct {
	Resource *Resource `json:"resource,omitempty"`
}

func (this *ReleaseRequest) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReleaseRequest)
	if !ok {
		that2, ok := that.(ReleaseRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.Resource == nil {
		if that1.Resource != nil {
			return false
		}
	} else if !this.Resource.Equal(*that1.Resource) {
		return false
	}
	return true
}
func (m *ReleaseRequest) GetResource() *Resource {
	if m != nil {
		return m.Resource
	}
	return nil
}
func (m *ReleaseRequest) SetResource(value *Resource) {
	if m != nil {
		m.Resource = value
	}
}
func (x *ReleaseRequest) ToProto() *ProtoReleaseRequest {
	if x == nil {
		return nil
	}

	proto := &ProtoReleaseRequest{
		Resource: x.Resource.ToProto(),
	}
	return proto
}

func (x *ProtoReleaseRequest) FromProto() *ReleaseRequest {
	if x == nil {
		return nil
	}

	copysafe := &ReleaseRequest{
		Resource: x.Resource.FromProto(),
	}
	return copysafe
}

func ReleaseRequestToProtoSlice(values []*ReleaseRequest) []*ProtoReleaseRequest {
	if values == nil {
		return nil
	}
	result := make([]*ProtoReleaseRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func ReleaseRequestFromProtoSlice(values []*ProtoReleaseRequest) []*ReleaseRequest {
	if values == nil {
		return nil
	}
	result := make([]*ReleaseRequest, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}

// Prevent copylock errors when using ProtoReleaseResponse directly
type ReleaseResponse struct {
}

func (this *ReleaseResponse) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReleaseResponse)
	if !ok {
		that2, ok := that.(ReleaseResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	return true
}
func (x *ReleaseResponse) ToProto() *ProtoReleaseResponse {
	if x == nil {
		return nil
	}

	proto := &ProtoReleaseResponse{}
	return proto
}

func (x *ProtoReleaseResponse) FromProto() *ReleaseResponse {
	if x == nil {
		return nil
	}

	copysafe := &ReleaseResponse{}
	return copysafe
}

func ReleaseResponseToProtoSlice(values []*ReleaseResponse) []*ProtoReleaseResponse {
	if values == nil {
		return nil
	}
	result := make([]*ProtoReleaseResponse, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func ReleaseResponseFromProtoSlice(values []*ProtoReleaseResponse) []*ReleaseResponse {
	if values == nil {
		return nil
	}
	result := make([]*ReleaseResponse, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}

// Prevent copylock errors when using ProtoFetchRequest directly
type FetchRequest struct {
	Key string `json:"key,omitempty"`
}

func (this *FetchRequest) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FetchRequest)
	if !ok {
		that2, ok := that.(FetchRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.Key != that1.Key {
		return false
	}
	return true
}
func (m *FetchRequest) GetKey() string {
	if m != nil {
		return m.Key
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *FetchRequest) SetKey(value string) {
	if m != nil {
		m.Key = value
	}
}
func (x *FetchRequest) ToProto() *ProtoFetchRequest {
	if x == nil {
		return nil
	}

	proto := &ProtoFetchRequest{
		Key: x.Key,
	}
	return proto
}

func (x *ProtoFetchRequest) FromProto() *FetchRequest {
	if x == nil {
		return nil
	}

	copysafe := &FetchRequest{
		Key: x.Key,
	}
	return copysafe
}

func FetchRequestToProtoSlice(values []*FetchRequest) []*ProtoFetchRequest {
	if values == nil {
		return nil
	}
	result := make([]*ProtoFetchRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func FetchRequestFromProtoSlice(values []*ProtoFetchRequest) []*FetchRequest {
	if values == nil {
		return nil
	}
	result := make([]*FetchRequest, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}

// Prevent copylock errors when using ProtoFetchResponse directly
type FetchResponse struct {
	Resource *Resource `json:"resource,omitempty"`
}

func (this *FetchResponse) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FetchResponse)
	if !ok {
		that2, ok := that.(FetchResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.Resource == nil {
		if that1.Resource != nil {
			return false
		}
	} else if !this.Resource.Equal(*that1.Resource) {
		return false
	}
	return true
}
func (m *FetchResponse) GetResource() *Resource {
	if m != nil {
		return m.Resource
	}
	return nil
}
func (m *FetchResponse) SetResource(value *Resource) {
	if m != nil {
		m.Resource = value
	}
}
func (x *FetchResponse) ToProto() *ProtoFetchResponse {
	if x == nil {
		return nil
	}

	proto := &ProtoFetchResponse{
		Resource: x.Resource.ToProto(),
	}
	return proto
}

func (x *ProtoFetchResponse) FromProto() *FetchResponse {
	if x == nil {
		return nil
	}

	copysafe := &FetchResponse{
		Resource: x.Resource.FromProto(),
	}
	return copysafe
}

func FetchResponseToProtoSlice(values []*FetchResponse) []*ProtoFetchResponse {
	if values == nil {
		return nil
	}
	result := make([]*ProtoFetchResponse, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func FetchResponseFromProtoSlice(values []*ProtoFetchResponse) []*FetchResponse {
	if values == nil {
		return nil
	}
	result := make([]*FetchResponse, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}

// Prevent copylock errors when using ProtoFetchAllRequest directly
type FetchAllRequest struct {
	// Deprecated: marked deprecated in locket.proto
	Type     string   `json:"type,omitempty"`
	TypeCode TypeCode `json:"typeCode,omitempty"`
}

func (this *FetchAllRequest) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FetchAllRequest)
	if !ok {
		that2, ok := that.(FetchAllRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.Type != that1.Type {
		return false
	}
	if this.TypeCode != that1.TypeCode {
		return false
	}
	return true
}

// Deprecated: marked deprecated in locket.proto
func (m *FetchAllRequest) GetType() string {
	if m != nil {
		return m.Type
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}

// Deprecated: marked deprecated in locket.proto
func (m *FetchAllRequest) SetType(value string) {
	if m != nil {
		m.Type = value
	}
}
func (m *FetchAllRequest) GetTypeCode() TypeCode {
	if m != nil {
		return m.TypeCode
	}
	var defaultValue TypeCode
	defaultValue = 0
	return defaultValue
}
func (m *FetchAllRequest) SetTypeCode(value TypeCode) {
	if m != nil {
		m.TypeCode = value
	}
}
func (x *FetchAllRequest) ToProto() *ProtoFetchAllRequest {
	if x == nil {
		return nil
	}

	proto := &ProtoFetchAllRequest{
		Type:     x.Type,
		TypeCode: ProtoTypeCode(x.TypeCode),
	}
	return proto
}

func (x *ProtoFetchAllRequest) FromProto() *FetchAllRequest {
	if x == nil {
		return nil
	}

	copysafe := &FetchAllRequest{
		Type:     x.Type,
		TypeCode: TypeCode(x.TypeCode),
	}
	return copysafe
}

func FetchAllRequestToProtoSlice(values []*FetchAllRequest) []*ProtoFetchAllRequest {
	if values == nil {
		return nil
	}
	result := make([]*ProtoFetchAllRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func FetchAllRequestFromProtoSlice(values []*ProtoFetchAllRequest) []*FetchAllRequest {
	if values == nil {
		return nil
	}
	result := make([]*FetchAllRequest, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}

// Prevent copylock errors when using ProtoFetchAllResponse directly
type FetchAllResponse struct {
	Resources []*Resource `json:"resources,omitempty"`
}

func (this *FetchAllResponse) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FetchAllResponse)
	if !ok {
		that2, ok := that.(FetchAllResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.Resources == nil {
		if that1.Resources != nil {
			return false
		}
	} else if len(this.Resources) != len(that1.Resources) {
		return false
	}
	for i := range this.Resources {
		if !this.Resources[i].Equal(that1.Resources[i]) {
			return false
		}
	}
	return true
}
func (m *FetchAllResponse) GetResources() []*Resource {
	if m != nil {
		return m.Resources
	}
	return nil
}
func (m *FetchAllResponse) SetResources(value []*Resource) {
	if m != nil {
		m.Resources = value
	}
}
func (x *FetchAllResponse) ToProto() *ProtoFetchAllResponse {
	if x == nil {
		return nil
	}

	proto := &ProtoFetchAllResponse{
		Resources: ResourceToProtoSlice(x.Resources),
	}
	return proto
}

func (x *ProtoFetchAllResponse) FromProto() *FetchAllResponse {
	if x == nil {
		return nil
	}

	copysafe := &FetchAllResponse{
		Resources: ResourceFromProtoSlice(x.Resources),
	}
	return copysafe
}

func FetchAllResponseToProtoSlice(values []*FetchAllResponse) []*ProtoFetchAllResponse {
	if values == nil {
		return nil
	}
	result := make([]*ProtoFetchAllResponse, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func FetchAllResponseFromProtoSlice(values []*ProtoFetchAllResponse) []*FetchAllResponse {
	if values == nil {
		return nil
	}
	result := make([]*FetchAllResponse, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}
